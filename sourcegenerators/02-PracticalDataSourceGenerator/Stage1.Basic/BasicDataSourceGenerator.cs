using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Immutable;
using System.Text;

namespace Stage1.Basic;

/// <summary>
/// Stage 1: Basic Data Source Generator
/// 
/// This is the simplest implementation demonstrating:
/// - Basic incremental source generation
/// - Attribute-based configuration
/// - Simple data generation without caching
/// 
/// Performance characteristics:
/// - No caching: All operations are recalculated on every build
/// - Single data source: Only processes attributes
/// - Baseline for comparison with later stages
/// </summary>
[Generator]
public class BasicDataSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the DataSource attribute for post-initialization
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "DataSourceAttribute.g.cs", SourceText.From(DataSourceAttributeSource, Encoding.UTF8)));

        // Find classes with DataSource attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m != null)
            .Collect();

        // Generate code for each class
        context.RegisterSourceOutput(classDeclarations, Execute);
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol == null)
            return null;

        // Check if the class has the DataSource attribute
        var dataSourceAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "DataSourceAttribute");

        if (dataSourceAttribute == null)
            return null;

        return new ClassInfo(
            classSymbol,
            classDeclaration,
            dataSourceAttribute);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<ClassInfo?> classes)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        ClassInfo?[] validClasses = [.. 
            classes.Where(c => c != null)];
        
        foreach (var classInfo in validClasses)
        {
            if (classInfo != null)
            {
                var source = GenerateDataClass(classInfo);
                context.AddSource($"{classInfo.Symbol.Name}_Generated.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateDataClass(ClassInfo classInfo)
    {
        var className = classInfo.Symbol.Name;
        var namespaceName = classInfo.Symbol.ContainingNamespace.ToDisplayString();
        
        // Extract configuration from attribute
        var entityName = GetAttributeValue<string>(classInfo.AttributeData, "EntityName") ?? className;
        var count = GetAttributeValue<int>(classInfo.AttributeData, "Count");
        if (count == 0) count = 10; // Default value

        IPropertySymbol[] properties = [.. 
            classInfo.Symbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod != null && !p.IsStatic)];

        string[] propertyGenerators = [.. properties.Select(GeneratePropertyAssignment)];

        return $$"""
            // <auto-generated/>
            // Stage 1: Basic Data Source Generator
            // Generated from: {{className}}
            // No caching - recalculated every build
            #nullable enable

            using System;
            using System.Collections.Generic;
            using System.Linq;

            namespace {{namespaceName}};

            /// <summary>
            /// Generated data factory for {{entityName}}
            /// Stage 1: Basic implementation without caching
            /// </summary>
            public static class {{className}}DataFactory
            {
                private static readonly Random _random = new();

                /// <summary>
                /// Creates a single sample {{entityName}}
                /// </summary>
                public static {{className}} CreateSample()
                {
                    return new {{className}}
                    {
                        {{string.Join(",\n            ", propertyGenerators)}}
                    };
                }

                /// <summary>
                /// Creates multiple sample {{entityName}} instances
                /// </summary>
                public static List<{{className}}> CreateSamples(int count = {{count}})
                {
                    var items = new List<{{className}}>();
                    for (int i = 0; i < count; i++)
                    {
                        items.Add(CreateSample());
                    }
                    return items;
                }

                /// <summary>
                /// Gets statistics about this generator stage
                /// </summary>
                public static string GetGeneratorInfo()
                {
                    return "Stage 1: Basic Data Source Generator - No caching, single data source (attributes)";
                }
            }
            """;
    }

    private static string GeneratePropertyAssignment(IPropertySymbol property)
    {
        var propertyName = property.Name;
        var typeName = property.Type.ToDisplayString();
        
        return $"{propertyName} = {GenerateTestValue(property.Type, propertyName)}";
    }

    private static string GenerateTestValue(ITypeSymbol type, string propertyName)
    {
        var typeName = type.ToDisplayString();
        
        return typeName switch
        {
            "string" => $"$\"Sample{propertyName}_{{_random.Next(1, 1000)}}\"",
            "int" => "_random.Next(1, 100)",
            "long" => "_random.NextInt64(1, 1000)",
            "decimal" => "((decimal)_random.NextDouble() * 1000)",
            "double" => "_random.NextDouble() * 1000",
            "float" => "((float)_random.NextDouble() * 1000)",
            "bool" => "_random.Next(0, 2) == 1",
            "System.Guid" => "Guid.NewGuid()",
            "System.DateTime" => "DateTime.Now.AddDays(_random.Next(-365, 365))",
            "System.DateTime?" => "_random.Next(0, 2) == 1 ? DateTime.Now.AddDays(_random.Next(-365, 365)) : null",
            _ when type.TypeKind == TypeKind.Enum => GenerateEnumValue(type),
            _ when typeName.EndsWith("?") => "null",
            _ => "default"
        };
    }

    private static string GenerateEnumValue(ITypeSymbol enumType)
    {
        var enumMembers = enumType.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.IsStatic && f.HasConstantValue)
            .ToArray();

        if (enumMembers.Length == 0)
            return "default";

        return $"({enumType.ToDisplayString()})_random.Next(0, {enumMembers.Length})";
    }

    private static T? GetAttributeValue<T>(AttributeData attributeData, string propertyName)
    {
        var namedArgument = attributeData.NamedArguments
            .FirstOrDefault(na => na.Key == propertyName);

        if (namedArgument.Key == propertyName && namedArgument.Value.Value is T value)
            return value;

        return default;
    }

    private const string DataSourceAttributeSource = """
        // <auto-generated/>
        #nullable enable

        using System;

        namespace Stage1.Basic.Attributes;

        /// <summary>
        /// Marks a class for data source generation in Stage 1
        /// Stage 1: Basic attribute-only data source
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
        public sealed class DataSourceAttribute : Attribute
        {
            /// <summary>
            /// The name of the entity being generated
            /// </summary>
            public string? EntityName { get; set; }

            /// <summary>
            /// Default number of items to generate in collections
            /// </summary>
            public int Count { get; set; } = 10;
        }
        """;
}
