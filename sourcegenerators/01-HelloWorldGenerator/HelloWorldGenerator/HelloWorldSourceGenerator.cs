using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using System.Text;

namespace HelloWorldGenerator;

[Generator]
public class HelloWorldSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a provider that triggers on compilation
        var compilationProvider = context.CompilationProvider;

        // Register the source generation
        context.RegisterSourceOutput(compilationProvider, static (spc, compilation) => Execute(spc, compilation));
    }

    private static void Execute(SourceProductionContext context, Compilation compilation)
    {
        // Generate the HelloWorld class with both methods
        var sourceCode = GenerateHelloWorldClass(compilation);

        context.AddSource("GeneratedHelloWorld.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static string GenerateHelloWorldClass(Compilation compilation)
    {
        var typesAndMethods = GetAvailableTypesAndMethodsInfo(compilation);
        var typeNamesArray = GenerateTypeNamesArray(compilation);
        
        return $$"""
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Generic;
            using System.Linq;

            namespace Generated;
            
            /// <summary>
            /// Auto-generated class containing HelloWorld functionality and type introspection
            /// </summary>
            public static class GeneratedHelloWorld
            {
                /// <summary>
                /// Returns the classic Hello World greeting
                /// </summary>
                /// <returns>Hello, World!</returns>
                public static string SayHello()
                {
                    return "Hello, World!";
                }

                /// <summary>
                /// Returns information about available types and methods in the compilation context
                /// </summary>
                /// <returns>A formatted string containing type and method information</returns>
                public static string GetAvailableTypesAndMethods()
                {
                    return @"{{typesAndMethods}}";
                }

                /// <summary>
                /// Returns a list of all available type names
                /// </summary>
                /// <returns>Array of type names</returns>
                public static string[] GetTypeNames()
                {
                    return new string[]
                    {
            {{typeNamesArray}}
                    };
                }
            }
            """;
    }

    private static string GetAvailableTypesAndMethodsInfo(Compilation compilation)
    {
        StringBuilder sb = new();
        sb.AppendLine("=== Compilation Context Information ===");
        sb.AppendLine($"Assembly: {compilation.AssemblyName}");
        sb.AppendLine($"Language: {compilation.Language}");
        sb.AppendLine();

        // Get all types in the compilation (excluding generated types to avoid recursion)
        List<INamedTypeSymbol> allTypes = [.. compilation.GlobalNamespace
            .GetNamespaceMembers()
            .SelectMany(GetTypesInNamespace)
            .Where(t => !t.Name.StartsWith("Generated") && !IsCompilerGenerated(t))
            .Take(10)]; // Limit to first 10 to keep output manageable

        sb.AppendLine("=== Available Types (first 10) ===");
        foreach (var type in allTypes)
        {
            sb.AppendLine($"Type: {type.ToDisplayString()}");

            // Get public methods for this type (limit to 3 per type)
            List<IMethodSymbol> methods = [.. type.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m => m.DeclaredAccessibility == Accessibility.Public &&
                           !m.IsImplicitlyDeclared &&
                           m.MethodKind == MethodKind.Ordinary)
                .Take(3)];

            foreach (var method in methods)
            {
                sb.AppendLine($"  Method: {method.Name}({string.Join(", ", method.Parameters.Select(p => p.Type.Name))})");
            }
            
            if (methods.Count == 0)
            {
                sb.AppendLine("  (No public methods)");
            }
            
            sb.AppendLine();
        }

        
        return sb.ToString().Replace("\"", "\\\"");
        // return sb.ToString().Replace("\"", "\\\"").Replace("\r\n", "\\n").Replace("\n", "\\n");
    }

    private static string GenerateTypeNamesArray(Compilation compilation)
    {
        List<string> typeNames = [.. compilation.GlobalNamespace
            .GetNamespaceMembers()
            .SelectMany(GetTypesInNamespace)
            .Where(t => !t.Name.StartsWith("Generated") && !IsCompilerGenerated(t))
            .Take(20) // Limit to first 20 type names
            .Select(t => $"            \"{t.ToDisplayString()}\"")];

        return string.Join(",\n", typeNames);
    }

    private static IEnumerable<INamedTypeSymbol> GetTypesInNamespace(INamespaceSymbol namespaceSymbol)
    {
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            yield return type;
        }

        foreach (var nestedNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            foreach (var type in GetTypesInNamespace(nestedNamespace))
            {
                yield return type;
            }
        }
    }

    private static bool IsCompilerGenerated(INamedTypeSymbol type)
    {
        return type.GetAttributes().Any(attr => 
            attr.AttributeClass?.ToDisplayString() == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
    }
}