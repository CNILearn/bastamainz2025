using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace TestDataGenerator;

[Generator]
public class TestDataGeneratorImpl : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the GenerateTestDataAttribute
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateTestDataAttribute.g.cs", SourceText.From(GenerateTestDataAttributeSource, Encoding.UTF8)));

        // Register the TestDataOptions class for external type configuration
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "TestDataOptions.g.cs", SourceText.From(TestDataOptionsSource, Encoding.UTF8)));

        // Find classes/records with GenerateTestDataAttribute
        var typesProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TestDataGenerator.Attributes.GenerateTestDataAttribute",
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (ctx, _) => GetTypeInfo(ctx))
            .Where(static t => t != null)
            .Collect();

        // Generate test data factory methods
        context.RegisterSourceOutput(typesProvider, static (spc, types) => Execute(spc, types));
    }

    private static TypeInfo? GetTypeInfo(GeneratorAttributeSyntaxContext context)
    {
        var typeDeclaration = context.TargetNode;
        var typeSymbol = context.TargetSymbol as INamedTypeSymbol;

        if (typeSymbol == null)
            return null;

        var attributeData = context.Attributes.FirstOrDefault();

        return new TypeInfo(
            typeSymbol,
            typeDeclaration,
            attributeData);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<TypeInfo?> types)
    {
        if (types.IsDefaultOrEmpty)
            return;

        var validTypes = types.Where(t => t != null).ToArray();

        // Group types by namespace
        var typesByNamespace = validTypes.GroupBy(t => t!.Symbol.ContainingNamespace.ToDisplayString());

        var namespacesSections = new List<string>();
        foreach (var namespaceGroup in typesByNamespace)
        {
            var factoriesInNamespace = new List<string>();
            foreach (var typeInfo in namespaceGroup)
            {
                if (typeInfo != null)
                {
                    factoriesInNamespace.Add(GenerateTestDataFactory(typeInfo));
                }
            }

            var namespaceSection = $$"""
                namespace {{namespaceGroup.Key}};

                {{string.Join("\n\n", factoriesInNamespace)}}
                """;
            namespacesSections.Add(namespaceSection);
        }

        var source = $$"""
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Generic;

            {{string.Join("\n\n", namespacesSections)}}
            """;

        context.AddSource("TestDataFactories.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateTestDataFactory(TypeInfo typeInfo)
    {
        var typeName = typeInfo.Symbol.Name;
        var fullTypeName = typeInfo.Symbol.ToDisplayString();
        var createSampleMethodBody = GenerateCreateSampleMethodBody(typeInfo);

        return $$"""
            /// <summary>
            /// Generated test data factory for {{typeName}}
            /// </summary>
            public static class {{typeName}}TestDataFactory
            {
                private static readonly Random _random = new();

                /// <summary>
                /// Creates a sample instance of {{typeName}} with populated test data
                /// </summary>
                public static {{fullTypeName}} CreateSample()
                {
            {{createSampleMethodBody}}
                }

                /// <summary>
                /// Creates multiple sample instances of {{typeName}}
                /// </summary>
                public static List<{{fullTypeName}}> CreateMany(int count = 10)
                {
                    var items = new List<{{fullTypeName}}>();
                    for (int i = 0; i < count; i++)
                    {
                        items.Add(CreateSample());
                    }
                    return items;
                }
            }
            """;
    }

    private static string GenerateCreateSampleMethodBody(TypeInfo typeInfo)
    {
        var typeName = typeInfo.Symbol.ToDisplayString();
        var properties = typeInfo.Symbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod != null && !p.IsStatic)
            .ToArray();

        List<string> propertyAssignments = [];
        for (int i = 0; i < properties.Length; i++)
        {
            var property = properties[i];
            var testValue = GenerateTestValue(property.Type, property.Name, typeInfo.AttributeData);
            propertyAssignments.Add($"{property.Name} = {testValue}");
        }

        return $$"""
            return new {{typeName}}
            {
            {{string.Join(",\n            ", propertyAssignments)}}
            };
            """;
    }

    private static string GenerateTestValue(ITypeSymbol type, string propertyName, AttributeData? attributeData)
    {
        var typeName = type.ToDisplayString();

        // Check for custom values in attribute
        var customValue = GetCustomValueFromAttribute(attributeData, propertyName, typeName);
        if (customValue != null)
            return customValue;

        return typeName switch
        {
            "string" => $"\"Sample{propertyName}\"",
            "int" => "_random.Next(1, 100)",
            "long" => "_random.NextInt64(1, 1000)",
            "bool" => "_random.Next(2) == 0",
            "System.DateTime" => "DateTime.Now.AddDays(_random.Next(-365, 365))",
            "System.DateTimeOffset" => "DateTimeOffset.Now.AddDays(_random.Next(-365, 365))",
            "System.Guid" => "Guid.NewGuid()",
            "double" => "_random.NextDouble() * 100",
            "float" => "(float)(_random.NextDouble() * 100)",
            "decimal" => "(decimal)(_random.NextDouble() * 100)",
            "byte" => "(byte)_random.Next(0, 256)",
            "short" => "(short)_random.Next(short.MinValue, short.MaxValue)",
            _ when type.TypeKind == TypeKind.Enum => GenerateEnumValue(type),
            _ when IsNullable(type) => GenerateNullableValue(type),
            _ => "default"
        };
    }

    private static string? GetCustomValueFromAttribute(AttributeData? attributeData, string propertyName, string typeName)
    {
        if (attributeData == null)
            return null;

        // Check for StringValue attribute property
        if (typeName == "string")
        {
            var stringValue = GetAttributeValue<string>(attributeData, "StringValue");
            if (stringValue != null)
                return $"\"{stringValue}\"";
        }

        // Check for IntRangeMin/Max
        if (typeName == "int")
        {
            var minValue = GetAttributeValue<int>(attributeData, "IntRangeMin");
            var maxValue = GetAttributeValue<int>(attributeData, "IntRangeMax");
            if (attributeData != null && (minValue != int.MinValue || maxValue != int.MaxValue))
            {
                var min = minValue == int.MinValue ? 1 : minValue;
                var max = maxValue == int.MaxValue ? 100 : maxValue;
                return $"_random.Next({min}, {max + 1})";
            }
        }

        return null;
    }

    private static T? GetAttributeValue<T>(AttributeData attributeData, string propertyName)
    {
        var namedArg = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == propertyName);
        if (namedArg.Value.Value is T value)
            return value;
        return default;
    }

    private static string GenerateEnumValue(ITypeSymbol enumType)
    {
        var enumTypeName = enumType.ToDisplayString();
        return $"({enumTypeName})_random.Next(0, Enum.GetValues<{enumTypeName}>().Length)";
    }

    private static bool IsNullable(ITypeSymbol type)
    {
        return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;
    }

    private static string GenerateNullableValue(ITypeSymbol nullableType)
    {
        if (nullableType is INamedTypeSymbol namedType && namedType.TypeArguments.Length == 1)
        {
            var underlyingType = namedType.TypeArguments[0];
            var underlyingValue = GenerateTestValue(underlyingType, "Value", null);
            return $"_random.Next(2) == 0 ? {underlyingValue} : null";
        }
        return "null";
    }

    private const string GenerateTestDataAttributeSource = """
// <auto-generated/>
#nullable enable
using System;

namespace TestDataGenerator.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = true)]
public sealed class GenerateTestDataAttribute : Attribute
{
    /// <summary>
    /// Fixed string value for string properties
    /// </summary>
    public string? StringValue { get; set; }
    
    /// <summary>
    /// Minimum value for integer range generation
    /// </summary>
    public int IntRangeMin { get; set; } = int.MinValue;
    
    /// <summary>
    /// Maximum value for integer range generation
    /// </summary>
    public int IntRangeMax { get; set; } = int.MaxValue;
    
    /// <summary>
    /// Whether to generate random data (default: true)
    /// </summary>
    public bool UseRandomData { get; set; } = true;
}
""";

    private const string TestDataOptionsSource = """
// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace TestDataGenerator;

/// <summary>
/// Configuration options for test data generation
/// </summary>
public class TestDataOptions
{
    private readonly Dictionary<Type, TypeConfiguration> _typeConfigurations = new();
    
    /// <summary>
    /// Configure test data generation for a specific type
    /// </summary>
    public TypeConfiguration<T> ForType<T>()
    {
        var config = new TypeConfiguration<T>();
        _typeConfigurations[typeof(T)] = config;
        return config;
    }
    
    /// <summary>
    /// Get configuration for a type
    /// </summary>
    internal TypeConfiguration? GetConfiguration(Type type)
    {
        return _typeConfigurations.TryGetValue(type, out var config) ? config : null;
    }
}

/// <summary>
/// Base configuration for a type
/// </summary>
public abstract class TypeConfiguration
{
    protected readonly Dictionary<string, object> PropertyConfigurations = new();
    
    /// <summary>
    /// Get configuration for a property
    /// </summary>
    internal object? GetPropertyConfiguration(string propertyName)
    {
        return PropertyConfigurations.TryGetValue(propertyName, out var config) ? config : null;
    }
}

/// <summary>
/// Typed configuration for a specific type
/// </summary>
public class TypeConfiguration<T> : TypeConfiguration
{
    /// <summary>
    /// Configure a property with a fixed value
    /// </summary>
    public TypeConfiguration<T> WithProperty<TProperty>(Expression<Func<T, TProperty>> property, TProperty value)
    {
        if (property.Body is MemberExpression memberExpr)
        {
            PropertyConfigurations[memberExpr.Member.Name] = value!;
        }
        return this;
    }
    
    /// <summary>
    /// Configure a property with a range for numeric types
    /// </summary>
    public TypeConfiguration<T> WithProperty<TProperty>(Expression<Func<T, TProperty>> property, (TProperty min, TProperty max) range)
        where TProperty : struct, IComparable<TProperty>
    {
        if (property.Body is MemberExpression memberExpr)
        {
            PropertyConfigurations[memberExpr.Member.Name] = range;
        }
        return this;
    }
}

/// <summary>
/// Global registry for test data configuration
/// </summary>
public static class TestDataRegistry
{
    private static TestDataOptions? _options;
    
    /// <summary>
    /// Register test data configuration
    /// </summary>
    public static void Register(Action<TestDataOptions> configure)
    {
        _options = new TestDataOptions();
        configure(_options);
    }
    
    /// <summary>
    /// Get current configuration
    /// </summary>
    internal static TestDataOptions? GetOptions() => _options;
}
""";

    public class TypeInfo
    {
        public INamedTypeSymbol Symbol { get; }
        public SyntaxNode Syntax { get; }
        public AttributeData? AttributeData { get; }

        public TypeInfo(INamedTypeSymbol symbol, SyntaxNode syntax, AttributeData? attributeData)
        {
            Symbol = symbol;
            Syntax = syntax;
            AttributeData = attributeData;
        }
    }
}