using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Immutable;
using System.Text;

namespace WeakEventSourceGenerator;

/// <summary>
/// A source generator that creates weak event patterns to prevent memory leaks
/// from event handler references. This generator transforms events marked with
/// [WeakEvent] into a weak reference-based event management system.
/// </summary>
[Generator]
public class WeakEventGenerator : IIncrementalGenerator
{
    private const string WeakEventAttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace WeakEventSourceGenerator.Attributes;

        /// <summary>
        /// Marks an event to be generated as a weak event, preventing memory leaks
        /// from event handler references. The generated weak event uses weak references
        /// to subscribers and automatically cleans up dead references.
        /// </summary>
        [System.AttributeUsage(System.AttributeTargets.Event)]
        public sealed class WeakEventAttribute : System.Attribute
        {
            /// <summary>
            /// Gets or sets whether to automatically clean up dead weak references.
            /// Default is true.
            /// </summary>
            public bool AutoCleanup { get; set; } = true;

            /// <summary>
            /// Gets or sets the cleanup threshold. When the number of dead references
            /// reaches this threshold, cleanup is triggered. Default is 10.
            /// </summary>
            public int CleanupThreshold { get; set; } = 10;
        }

        /// <summary>
        /// Marks a partial class to have weak events generated for its events
        /// marked with [WeakEvent].
        /// </summary>
        [System.AttributeUsage(System.AttributeTargets.Class)]
        public sealed class GenerateWeakEventsAttribute : System.Attribute
        {
        }
        """;

    private const string WeakEventManagerSource = """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Runtime.CompilerServices;

        namespace WeakEventSourceGenerator;

        /// <summary>
        /// Manages weak references to event handlers, preventing memory leaks
        /// while maintaining event functionality.
        /// </summary>
        /// <typeparam name="TDelegate">The delegate type being managed.</typeparam>
        public sealed class WeakEventManager<TDelegate> where TDelegate : Delegate
        {
            private readonly List<WeakReference> _handlers = [];
            private readonly bool _autoCleanup;
            private readonly int _cleanupThreshold;
            private int _deadReferenceCount;

            /// <summary>
            /// Initializes a new WeakEventManager.
            /// </summary>
            /// <param name="autoCleanup">Whether to automatically clean up dead references.</param>
            /// <param name="cleanupThreshold">The threshold for triggering automatic cleanup.</param>
            public WeakEventManager(bool autoCleanup = true, int cleanupThreshold = 10)
            {
                _autoCleanup = autoCleanup;
                _cleanupThreshold = Math.Max(1, cleanupThreshold);
            }

            /// <summary>
            /// Gets the number of active (alive) subscribers.
            /// </summary>
            public int SubscriberCount
            {
                get
                {
                    lock (_handlers)
                    {
                        return _handlers.Count(wr => wr.IsAlive);
                    }
                }
            }

            /// <summary>
            /// Subscribes a delegate to the weak event.
            /// /// </summary>
            /// <param name="handler">The delegate to subscribe.</param>
            public void Subscribe(TDelegate handler)
            {
                if (handler is null) return;

                lock (_handlers)
                {
                    // Check if already subscribed (compare targets and methods)
                    foreach (var existingWr in _handlers)
                    {
                        if (existingWr.Target is TDelegate existing && 
                            ReferenceEquals(existing.Target, handler.Target) &&
                            existing.Method == handler.Method)
                        {
                            return; // Already subscribed
                        }
                    }

                    _handlers.Add(new WeakReference(handler));
                    
                    if (_autoCleanup && _deadReferenceCount >= _cleanupThreshold)
                    {
                        CleanupInternal();
                    }
                }
            }

            /// <summary>
            /// Unsubscribes a delegate from the weak event.
            /// </summary>
            /// <param name="handler">The delegate to unsubscribe.</param>
            public void Unsubscribe(TDelegate handler)
            {
                if (handler is null) return;

                lock (_handlers)
                {
                    for (int i = _handlers.Count - 1; i >= 0; i--)
                    {
                        var wr = _handlers[i];
                        if (!wr.IsAlive)
                        {
                            _handlers.RemoveAt(i);
                            _deadReferenceCount++;
                            continue;
                        }

                        if (wr.Target is TDelegate existing &&
                            ReferenceEquals(existing.Target, handler.Target) &&
                            existing.Method == handler.Method)
                        {
                            _handlers.RemoveAt(i);
                            break;
                        }
                    }
                }
            }

            /// <summary>
            /// Invokes all alive event handlers.
            /// </summary>
            /// <param name="args">Arguments to pass to the handlers.</param>
            public void Invoke(params object?[] args)
            {
                List<TDelegate> aliveHandlers;

                lock (_handlers)
                {
                    aliveHandlers = [];
                    
                    for (int i = _handlers.Count - 1; i >= 0; i--)
                    {
                        var wr = _handlers[i];
                        if (!wr.IsAlive)
                        {
                            _handlers.RemoveAt(i);
                            _deadReferenceCount++;
                        }
                        else if (wr.Target is TDelegate handler)
                        {
                            aliveHandlers.Add(handler);
                        }
                    }

                    if (_autoCleanup && _deadReferenceCount >= _cleanupThreshold)
                    {
                        CleanupInternal();
                    }
                }

                // Invoke outside the lock to avoid potential deadlocks
                foreach (var handler in aliveHandlers)
                {
                    try
                    {
                        handler.DynamicInvoke(args);
                    }
                    catch (Exception ex)
                    {
                        // Consider logging this exception or providing a way to handle it
                        System.Diagnostics.Debug.WriteLine($"Exception in weak event handler: {ex}");
                    }
                }
            }

            /// <summary>
            /// Manually cleans up dead weak references.
            /// </summary>
            public void Cleanup()
            {
                lock (_handlers)
                {
                    CleanupInternal();
                }
            }

            private void CleanupInternal()
            {
                for (int i = _handlers.Count - 1; i >= 0; i--)
                {
                    if (!_handlers[i].IsAlive)
                    {
                        _handlers.RemoveAt(i);
                    }
                }
                _deadReferenceCount = 0;
            }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the WeakEvent attribute
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "WeakEventAttribute.g.cs", SourceText.From(WeakEventAttributeSource, Encoding.UTF8)));

        // Register the WeakEventManager helper class
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "WeakEventManager.g.cs", SourceText.From(WeakEventManagerSource, Encoding.UTF8)));

        // Find partial events with WeakEvent attribute
        var eventsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "WeakEventSourceGenerator.Attributes.WeakEventAttribute",
                predicate: static (node, _) => IsSyntaxTargetForGeneration(node),
                static (ctx, _) => GetEventInfo(ctx))
            .Where(static e => e != null)
            .Collect();

        // Generate weak event implementations
        context.RegisterSourceOutput(eventsProvider, static (spc, events) =>
        {
            if (events.IsDefaultOrEmpty) return;
            
            var validEvents = ImmutableArray.CreateBuilder<EventInfo>();
            foreach (var evt in events)
            {
                if (evt is not null)
                    validEvents.Add(evt);
            }
            
            if (validEvents.Count > 0)
                Execute(spc, validEvents.ToImmutable());
        });
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // Handle property-like events with explicit add/remove accessors
        if (node is EventDeclarationSyntax eventDecl)
        {
            return eventDecl.Modifiers.Any(SyntaxKind.PartialKeyword);
        }

        // Handle field-like events (which create VariableDeclaratorSyntax nodes)
        if (node is VariableDeclaratorSyntax variableDecl)
        {
            // Check if this is within an EventFieldDeclarationSyntax with partial modifier
            if (variableDecl.Parent?.Parent is EventFieldDeclarationSyntax eventFieldDecl)
            {
                return eventFieldDecl.Modifiers.Any(SyntaxKind.PartialKeyword);
            }
        }
        return false;
    }

    private static EventInfo? GetEventInfo(GeneratorAttributeSyntaxContext context)
    {
        EventFieldDeclarationSyntax? eventFieldSyntax = null;
        EventDeclarationSyntax? eventDeclarationSyntax = null;
        
        // Handle field-like events (VariableDeclaratorSyntax)
        if (context.TargetNode is VariableDeclaratorSyntax variableDecl)
        {
            if (variableDecl.Parent?.Parent is EventFieldDeclarationSyntax eventField)
            {
                eventFieldSyntax = eventField;
            }
            else
            {
                return null;
            }
        }
        // Handle property-like events (EventDeclarationSyntax)
        else if (context.TargetNode is EventDeclarationSyntax eventDecl)
        {
            eventDeclarationSyntax = eventDecl;
        }
        else
        {
            return null;
        }

        if (context.TargetSymbol is not IEventSymbol eventSymbol)
            return null;

        // Check for partial modifier
        bool isPartial = false;
        if (eventFieldSyntax != null)
        {
            isPartial = eventFieldSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        }
        else if (eventDeclarationSyntax != null)
        {
            isPartial = eventDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
        }
        
        if (!isPartial)
            return null;

        var attributeData = context.Attributes.FirstOrDefault();
        var autoCleanup = GetAttributeValue<bool>(attributeData, "AutoCleanup", true);
        var cleanupThreshold = GetAttributeValue<int>(attributeData, "CleanupThreshold", 10);

        return new EventInfo(
            eventSymbol,
            eventFieldSyntax ?? (SyntaxNode)eventDeclarationSyntax!,
            attributeData,
            autoCleanup,
            cleanupThreshold);
    }

    private static T GetAttributeValue<T>(AttributeData? attributeData, string propertyName, T defaultValue)
    {
        if (attributeData?.NamedArguments.FirstOrDefault(kvp => kvp.Key == propertyName).Value.Value is T value)
        {
            return value;
        }
        return defaultValue;
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<EventInfo> events)
    {
        if (events.IsDefaultOrEmpty)
            return;

        // Group events by containing class using SymbolEqualityComparer
        var eventsByClass = events
            .Where(e => e.Symbol.ContainingType is not null)
            .GroupBy(e => e.Symbol.ContainingType, SymbolEqualityComparer.Default)
            .ToList();

        foreach (var classGroup in eventsByClass)
        {
            ISymbol classSymbol = classGroup.Key!;
            var classEvents = classGroup.ToArray();
            
            var sourceCode = GeneratePartialEventClass((INamedTypeSymbol)classSymbol, classEvents);
            var fileName = $"{classSymbol.Name}.WeakEvents.g.cs";
            context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GeneratePartialEventClass(INamedTypeSymbol classSymbol, EventInfo[] events)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var eventsContent = string.Join("\n\n    ", events.Select(GeneratePartialEventImplementation));

        var namespaceDeclaration = !string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>"
            ? $"namespace {namespaceName};"
            : "";

        return $$"""
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Runtime.CompilerServices;

            {{namespaceDeclaration}}

            partial class {{className}}
            {
                {{eventsContent}}
            }
            """;
    }

    private static string GeneratePartialEventImplementation(EventInfo eventInfo)
    {
        var eventName = eventInfo.Symbol.Name;
        var eventType = eventInfo.Symbol.Type.ToDisplayString();
        var delegateTypeName = GetDelegateTypeName(eventType);
        var managerFieldName = $"_{char.ToLower(eventName[0])}{eventName.Substring(1)}Manager";
        var cleanupThreshold = eventInfo.CleanupThreshold;
        var autoCleanup = eventInfo.AutoCleanup ? "true" : "false";
        
        // Extract access modifier from the original event declaration
        var accessModifier = GetAccessModifier(eventInfo);

        return $$"""
            private WeakEventManager<{{delegateTypeName}}>? {{managerFieldName}};

            /// <summary>
            /// Implementation for partial event {{eventName}} using weak references.
            /// Prevents memory leaks by allowing subscribers to be garbage collected.
            /// </summary>
            {{accessModifier}} partial event {{eventType}} {{eventName}}
            {
                add
                {
                    if (value is null) return;
                    {{managerFieldName}} ??= new WeakEventManager<{{delegateTypeName}}>({{autoCleanup}}, {{cleanupThreshold}});
                    {{managerFieldName}}.Subscribe(value);
                }
                remove
                {
                    if (value is null) return;
                    {{managerFieldName}}?.Unsubscribe(value);
                }
            }

            /// <summary>
            /// Gets the number of active subscribers for {{eventName}}.
            /// </summary>
            public int Get{{eventName}}SubscriberCount()
            {
                return {{managerFieldName}}?.SubscriberCount ?? 0;
            }

            /// <summary>
            /// Manually triggers cleanup of dead weak references for {{eventName}}.
            /// </summary>
            public void Cleanup{{eventName}}()
            {
                {{managerFieldName}}?.Cleanup();
            }

            /// <summary>
            /// Raises the {{eventName}} event using weak references with automatic cleanup.
            /// </summary>
            protected virtual void On{{eventName}}({{GetEventParametersSignature(eventType)}})
            {
                {{managerFieldName}}?.Invoke({{GetEventParametersCall(eventType)}});
            }
            """;
    }

    private static string GetAccessModifier(EventInfo eventInfo)
    {
        SyntaxTokenList modifiers;
        
        // Get modifiers from the appropriate syntax node
        if (eventInfo.Syntax is EventFieldDeclarationSyntax eventFieldSyntax)
        {
            modifiers = eventFieldSyntax.Modifiers;
        }
        else if (eventInfo.Syntax is EventDeclarationSyntax eventDeclarationSyntax)
        {
            modifiers = eventDeclarationSyntax.Modifiers;
        }
        else
        {
            return "public"; // fallback
        }

        // Extract access modifier keywords and preserve their order
        var accessModifierTokens = modifiers
            .Where(token => IsAccessModifier(token.Kind()))
            .ToList();

        if (accessModifierTokens.Count == 0)
        {
            // No explicit access modifier means internal for top-level types/members
            return "internal";
        }

        // Build access modifier string (e.g., "protected internal")
        return string.Join(" ", accessModifierTokens.Select(token => token.ValueText));
    }

    private static bool IsAccessModifier(SyntaxKind kind)
    {
        return kind switch
        {
            SyntaxKind.PublicKeyword => true,
            SyntaxKind.PrivateKeyword => true,
            SyntaxKind.ProtectedKeyword => true,
            SyntaxKind.InternalKeyword => true,
            _ => false
        };
    }

    private static string GetDelegateTypeName(string eventType)
    {
        // Handle generic delegates like Action<T>, Func<T>, EventHandler<T>
        if (eventType.Contains('<'))
        {
            return eventType;
        }

        // Handle simple delegates
        return eventType switch
        {
            "System.Action" => "Action",
            "System.EventHandler" => "EventHandler",
            _ => eventType
        };
    }

    private static string GetEventParametersSignature(string eventType)
    {
        return eventType switch
        {
            var t when t.StartsWith("System.Action<") => ExtractActionParameters(t),
            var t when t.StartsWith("Action<") => ExtractActionParameters(t),
            var t when t.StartsWith("System.EventHandler<") => "object? sender, " + ExtractEventHandlerParameters(t),
            var t when t.StartsWith("EventHandler<") => "object? sender, " + ExtractEventHandlerParameters(t),
            "System.Action" or "Action" => "",
            "System.EventHandler" or "EventHandler" => "object? sender, EventArgs e",
            _ => "object? sender, EventArgs e"
        };
    }

    private static string GetEventParametersCall(string eventType)
    {
        return eventType switch
        {
            var t when t.StartsWith("System.Action<") => ExtractActionParametersCall(t),
            var t when t.StartsWith("Action<") => ExtractActionParametersCall(t),
            var t when t.StartsWith("System.EventHandler<") => "sender, " + ExtractEventHandlerParametersCall(t),
            var t when t.StartsWith("EventHandler<") => "sender, " + ExtractEventHandlerParametersCall(t),
            "System.Action" or "Action" => "",
            "System.EventHandler" or "EventHandler" => "sender, e",
            _ => "sender, e"
        };
    }

    private static string ExtractActionParameters(string actionType)
    {
        // Extract T from Action<T> and create parameter list
        var start = actionType.IndexOf('<') + 1;
        var end = actionType.LastIndexOf('>');
        if (start >= end) return "";

        var types = actionType.Substring(start, end - start).Split(',');
        return string.Join(", ", types.Select((t, i) => $"{t.Trim()} arg{i}"));
    }

    private static string ExtractActionParametersCall(string actionType)
    {
        var start = actionType.IndexOf('<') + 1;
        var end = actionType.LastIndexOf('>');
        if (start >= end) return "";

        var types = actionType.Substring(start, end - start).Split(',');
        return string.Join(", ", types.Select((_, i) => $"arg{i}"));
    }

    private static string ExtractEventHandlerParameters(string eventHandlerType)
    {
        var start = eventHandlerType.IndexOf('<') + 1;
        var end = eventHandlerType.LastIndexOf('>');
        if (start >= end) return "EventArgs e";

        var eventArgsType = eventHandlerType.Substring(start, end - start).Trim();
        return $"{eventArgsType} e";
    }

    private static string ExtractEventHandlerParametersCall(string eventHandlerType)
    {
        return "e";
    }

    private class EventInfo
    {
        public IEventSymbol Symbol { get; }
        public SyntaxNode Syntax { get; } // Changed from EventDeclarationSyntax to SyntaxNode to handle both types
        public AttributeData? AttributeData { get; }
        public bool AutoCleanup { get; }
        public int CleanupThreshold { get; }

        public EventInfo(IEventSymbol symbol, SyntaxNode syntax, AttributeData? attributeData, bool autoCleanup, int cleanupThreshold)
        {
            Symbol = symbol;
            Syntax = syntax;
            AttributeData = attributeData;
            AutoCleanup = autoCleanup;
            CleanupThreshold = cleanupThreshold;
        }
    }
}