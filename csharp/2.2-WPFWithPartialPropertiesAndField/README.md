# C# 14 Field Keyword WPF MVVM Sample with CommunityToolkit.MVVM

A comprehensive demonstration of C# 14's new `field` keyword combined with CommunityToolkit.MVVM source generators in a Windows Presentation Foundation (WPF) application using the Model-View-ViewModel (MVVM) pattern. This sample showcases how modern C# features and source generation improve code readability, maintainability, and development experience in real-world MVVM scenarios.

## ğŸš€ Features

- **CommunityToolkit.MVVM Source Generators**: Modern MVVM implementation with source-generated properties and commands
- **C# 14 Field Keyword**: Demonstrates field-backed properties with the new `field` keyword
- **Partial Properties**: Utilizes partial properties with `[ObservableProperty]` attributes for cleaner code
- **WPF MVVM Pattern**: Complete MVVM implementation with proper separation of concerns
- **Enhanced Debugging**: Shows improved debugging experience with source-generated code
- **Property Validation**: Demonstrates validation logic using partial methods
- **Data Binding**: Full two-way data binding between Views and ViewModels
- **Source-Generated Commands**: `[RelayCommand]` attributes for automatic command generation
- **Modern UI**: Clean, responsive WPF interface with proper styling

## ğŸ“‹ Prerequisites

- **.NET 10 RC 1 SDK** or later
- **Visual Studio 2026** or **VS Code** with C# extension
- **Windows** (for WPF support)
- **CommunityToolkit.Mvvm** NuGet package (version 8.4.0 or later)

## ğŸ—ï¸ Architecture

```
CSharp14FieldKeywordWpf/
â”œâ”€â”€ Models/                          # Domain models with source generators
â”‚   â””â”€â”€ UserProfile.cs              # User model with [ObservableProperty] attributes
â”œâ”€â”€ ViewModels/                      # MVVM ViewModels with source generation
â”‚   â”œâ”€â”€ MainViewModel.cs            # Main ViewModel with generated properties/commands
â”‚   â””â”€â”€ Converters.cs               # Value converters for data binding
â”œâ”€â”€ Views/                           # WPF Views and Windows
â”‚   â”œâ”€â”€ MainWindow.xaml             # Main application window
â”‚   â””â”€â”€ MainWindow.xaml.cs          # Code-behind
â”œâ”€â”€ App.xaml                        # Application resources and startup
â”œâ”€â”€ App.xaml.cs                     # Application entry point
â”œâ”€â”€ CSharp14FieldKeywordWpf.csproj  # Project configuration with CommunityToolkit.Mvvm
â”œâ”€â”€ MVVM_Migration_Summary.md       # Migration documentation
â””â”€â”€ README.md                       # This file
```

## ğŸ”§ Setup

### 1. Install Dependencies

```bash
# Navigate to project directory
cd CSharp14FieldKeywordWpfWithSourceGenerator

# Restore NuGet packages (includes CommunityToolkit.Mvvm)
dotnet restore
```

### 2. Build the Project

```bash
# Build the application (triggers source generation)
dotnet build
```

### 3. Run the Application

```bash
# Run the WPF application
dotnet run
```

## ğŸ’¡ Key Concepts

### CommunityToolkit.MVVM Source Generation with Partial Properties

The modern approach uses CommunityToolkit.MVVM source generators with partial properties and the `field` keyword:

#### Source-Generated Properties with Partial Properties

```csharp
public partial class UserProfile : ObservableObject
{
    /// <summary>
    /// First name with validation using ObservableProperty on partial property
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(FullName))]
    public partial string FirstName { get; set; } = string.Empty;

    /// <summary>
    /// Last name with validation using ObservableProperty on partial property
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(FullName))]
    public partial string LastName { get; set; } = string.Empty;

    /// <summary>
    /// Age with range validation using partial property
    /// </summary>
    [ObservableProperty]
    public partial int Age { get; set; }

    /// <summary>
    /// Computed full name property - leverages generated properties
    /// </summary>
    public string FullName => $"{FirstName} {LastName}";

    // Validation methods using partial methods generated by source generator
    partial void OnFirstNameChanging(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("First name cannot be empty");
    }

    partial void OnAgeChanging(int value)
    {
        if (value < 0 || value > 150)
            throw new ArgumentOutOfRangeException(nameof(value), "Age must be between 0 and 150");
    }
}
```

#### What the Source Generator Creates

For each `[ObservableProperty]` partial property, the source generator creates the implementation:

```csharp
// You write:
[ObservableProperty]
public partial string FirstName { get; set; } = string.Empty;

// Source generator creates the implementation:

public string FirstName
{
    get => field;
    set
    {
        if (SetProperty(ref field, value))
        {
            OnFirstNameChanging(value);  // Validation hook (if defined)
            OnFirstNameChanged(value);   // Change notification hook (if defined)
        }
    }
}
```

#### Source-Generated Commands

```csharp
public partial class MainViewModel : ObservableObject
{
    [RelayCommand(CanExecute = nameof(CanSaveUser))]
    private async Task SaveUserAsync()
    {
        // Command implementation
        SelectedUser?.UpdateLastLogin();
        StatusMessage = "User saved successfully!";
    }

    private bool CanSaveUser() => !IsBusy && SelectedUser != null;

    // Source generator creates:
    // public IAsyncRelayCommand SaveUserCommand { get; }
    // with automatic CanExecute binding and async support
}
```

### Key Improvements with Source Generation

1. **Zero Boilerplate**: No manual property or command implementations
2. **Compile-Time Generation**: Better performance than runtime solutions
3. **Automatic Validation Hooks**: Partial methods for property validation
4. **Consistent Naming**: Automatic property name generation
5. **IntelliSense Support**: Full IDE support for generated members
6. **Debugging**: Source-generated code is debuggable and inspectable

### MVVM Pattern with Source Generation

The sample demonstrates modern MVVM with source generators:

- **Models**: Partial classes with `[ObservableProperty]` attributes
- **ViewModels**: Generated properties and commands with minimal boilerplate
- **Views**: XAML-based UI binding to generated properties and commands

### Property Change Notification (Generated)

The source generator handles all `INotifyPropertyChanged` implementation:

```csharp
// You define:
[ObservableProperty]
public partial bool IsBusy { get; set; }

// Source generator creates full implementation with:
// - Backing field management
// - Property change notifications
// - Equality checking
// - Partial method hooks
```

## ğŸ¯ Use Cases Demonstrated

### 1. Property Validation with Partial Methods

```csharp
[ObservableProperty]
public partial string Email { get; set; } = string.Empty;

partial void OnEmailChanging(string value)
{
    if (string.IsNullOrWhiteSpace(value) || !new EmailAddressAttribute().IsValid(value))
        throw new ArgumentException("Invalid email address");
}
```

### 2. Dependent Property Notifications

```csharp
[ObservableProperty]
[NotifyPropertyChangedFor(nameof(FullName))]
public partial string FirstName { get; set; } = string.Empty;

[ObservableProperty]
[NotifyPropertyChangedFor(nameof(FullName))]
public partial string LastName { get; set; } = string.Empty;

public string FullName => $"{FirstName} {LastName}";
```

### 3. Command Generation with CanExecute

```csharp
[RelayCommand(CanExecute = nameof(CanDeleteUser))]
private async Task DeleteUserAsync()
{
    // Implementation
}

private bool CanDeleteUser() => !IsBusy && SelectedUser != null;

// Generates: public IAsyncRelayCommand DeleteUserCommand { get; }
```

### 4. State Management with Change Notifications

```csharp
[ObservableProperty]
public partial UserProfile? SelectedUser { get; set; }

partial void OnSelectedUserChanged(UserProfile? value)
{
    // Update command states when selection changes
    SaveUserCommand.NotifyCanExecuteChanged();
    DeleteUserCommand.NotifyCanExecuteChanged();
}
```

## ğŸ” Sample Operations

### User Management
- **Add User**: Creates new user profiles with source-generated commands
- **Edit User**: Modify user properties with real-time validation via partial methods
- **Delete User**: Remove users with automatic command state management
- **Save User**: Persist changes with generated async commands

### Source Generation Features
- **Property Generation**: Automatic property implementation from partial declarations
- **Command Generation**: Full `ICommand` implementations from method attributes
- **Validation Hooks**: Partial methods for property change validation
- **Change Notifications**: Automatic dependent property updates

### Data Validation (Generated)
- **Email Validation**: Validation via `OnEmailChanging` partial method
- **Age Range**: Validation via `OnAgeChanging` partial method
- **Required Fields**: Validation via `OnFirstNameChanging` and `OnLastNameChanging`
- **Positive Values**: Validation via `OnSalaryChanging` partial method

### UI Features
- **Responsive Layout**: Adapts to window resizing
- **Status Messages**: Shows operation feedback with auto-clear
- **Loading Indicators**: Visual feedback during async operations
- **Data Binding**: Two-way binding to generated properties

## ğŸ§  Source Generation Benefits

The CommunityToolkit.MVVM source generators provide:

1. **Compile-Time Safety**: Errors caught at compile time, not runtime
2. **Performance**: No reflection overhead, pure generated code
3. **Debugging**: Generated code is fully debuggable
4. **IntelliSense**: Complete IDE support for generated members
5. **Maintainability**: Less code to write and maintain
6. **Consistency**: Standardized implementations across the application

## ğŸ“Š Generated Code Structure

When you build the project, the source generator creates:

```
Generated Files (in obj/Debug/net10.0-windows/generated/):
â”œâ”€â”€ CommunityToolkit.Mvvm.SourceGenerators/
â”‚   â”œâ”€â”€ UserProfile.Properties.g.cs         # Generated property implementations
â”‚   â”œâ”€â”€ MainViewModel.Properties.g.cs       # Generated ViewModel properties
â”‚   â””â”€â”€ MainViewModel.Commands.g.cs         # Generated command implementations
```

## ğŸ”— Package Dependencies

```xml
<PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
```

The CommunityToolkit.Mvvm package provides:
- **Source Generators**: For properties and commands
- **Base Classes**: `ObservableObject`, `RelayCommand`, etc.
- **Attributes**: `[ObservableProperty]`, `[RelayCommand]`, etc.
- **Interfaces**: `INotifyPropertyChanged`, `ICommand`, etc.

## ğŸ“š Generated Code Examples

### Property Generation
```csharp
// Source (what you write):
[ObservableProperty]
public partial string FirstName { get; set; } = string.Empty;

// Generated (what the compiler creates):
private string firstName = string.Empty;
public string FirstName
{
    get => firstName;
    set => SetProperty(ref firstName, value);
}
```

### Command Generation
```csharp
// Source (what you write):
[RelayCommand]
private async Task SaveUserAsync() { /* implementation */ }

// Generated (what the compiler creates):
private AsyncRelayCommand? saveUserCommand;
public IAsyncRelayCommand SaveUserCommand => 
    saveUserCommand ??= new AsyncRelayCommand(SaveUserAsync);
```

## ğŸ“š Additional Resources

- [CommunityToolkit.MVVM Documentation](https://docs.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)
- [C# 14 Field Keyword Documentation](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-14.0/field-keyword)
- [Source Generators in C#](https://docs.microsoft.com/dotnet/csharp/roslyn-sdk/source-generators-overview)
- [WPF MVVM Pattern Guide](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/mvvm)
- [.NET 10 Release Notes](https://docs.microsoft.com/dotnet/core/whats-new/dotnet-10)

## ğŸ¤ Contributing

This sample demonstrates modern MVVM patterns with source generation. Feel free to submit issues and enhancement requests!

## ğŸ“„ License

This sample is licensed under the MIT License. See LICENSE file for details.